<?php

use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;

/**
 * Ensures timerange field and displays are correctly configured.
 *
 * This helper function is idempotent and safe to run multiple times. It
 * handles the creation and updating of the 'field_appointment_timerange'
 * field, its storage, and its displays, correctly switching between 'daterange'
 * and 'smartdate' field types based on whether the Smart Date module is
 * enabled.
 */
function _appointment_facilitator_ensure_timerange_and_displays() {
  $smart_date_enabled = \Drupal::moduleHandler()->moduleExists('smart_date');
  $field_storage_name = 'field_appointment_timerange';
  $entity_type = 'node';
  $bundle = 'appointment';
  $target_type = $smart_date_enabled ? 'smartdate' : 'daterange';
  $smart_date_duration = 60;
  $smart_date_duration_increments = "15\n30\n45\n60\n90\n120";

  // === 1. Field Storage ===
  $storage = FieldStorageConfig::loadByName($entity_type, $field_storage_name);

  if ($storage) {
    // Storage exists, check if it needs to be updated.
    $needs_save = FALSE;

    // Update field type if it doesn't match the target type.
    if ($storage->getType() !== $target_type) {
      $storage->set('type', $target_type);
      $needs_save = TRUE;
    }

    // Update settings based on whether Smart Date is enabled.
    $settings = $storage->getSettings();
    $original_settings = $settings;

    if ($smart_date_enabled) {
      $settings['end_field'] = TRUE;
      if (!isset($settings['default_duration'])) {
        $settings['default_duration'] = $smart_date_duration;
      }
      if (!isset($settings['default_duration_increments'])) {
        $settings['default_duration_increments'] = $smart_date_duration_increments;
      }
    }
    else {
      // If smart_date is disabled, remove its specific settings.
      unset($settings['default_duration'], $settings['default_duration_increments']);
    }

    if ($settings !== $original_settings) {
      $storage->setSettings($settings);
      $needs_save = TRUE;
    }

    if ($needs_save) {
      $storage->save();
    }
  }
  else {
    // Storage does not exist, create it.
    $settings = ['end_field' => TRUE];
    if ($smart_date_enabled) {
      $settings['default_duration'] = $smart_date_duration;
      $settings['default_duration_increments'] = $smart_date_duration_increments;
    }
    FieldStorageConfig::create([
      'field_name' => $field_storage_name,
      'entity_type' => $entity_type,
      'type' => $target_type,
      'settings' => $settings,
      'cardinality' => 1,
    ])->save();
  }

  // === 2. Field Instance ===
  $field_instance = FieldConfig::loadByName($entity_type, $bundle, $field_storage_name);
  $instance_needs_save = FALSE;
  if (!$field_instance) {
    $field_instance = FieldConfig::create([
      'field_name' => $field_storage_name,
      'entity_type' => $entity_type,
      'bundle' => $bundle,
      'label' => 'Appointment Time (Range)',
      'settings' => [],
    ]);
    $instance_needs_save = TRUE;
  }

  $default_value = $field_instance->get('default_value');
  if ($smart_date_enabled) {
    $duration_defaults = [
      'default_duration' => $smart_date_duration,
      'default_duration_increments' => $smart_date_duration_increments,
    ];
    $duration_config = [];
    if (is_array($default_value) && !empty($default_value)) {
      $duration_config = $default_value[0] ?? [];
    }
    $duration_config = array_intersect_key($duration_config, $duration_defaults);
    $duration_config = array_merge($duration_defaults, $duration_config);
    $expected_default = [$duration_config];
    if ($default_value !== $expected_default) {
      $field_instance->set('default_value', $expected_default);
      $instance_needs_save = TRUE;
    }
  }
  elseif (!empty($default_value)) {
    $field_instance->set('default_value', []);
    $instance_needs_save = TRUE;
  }

  if ($instance_needs_save) {
    $field_instance->save();
  }

  $em = \Drupal::entityTypeManager();

  // === 3. Form Display ===
  if ($fd = $em->getStorage('entity_form_display')->load('node.appointment.default')) {
    $target_widget = $smart_date_enabled ? 'smartdate_inline' : 'daterange_default';
    $component = $fd->getComponent($field_storage_name);
    $needs_save = FALSE;

    // Check if the component needs to be updated due to wrong type.
    if (!$component || $component['type'] !== $target_widget) {
      $needs_save = TRUE;
    }

    $new_settings = $component['settings'] ?? [];
    $original_settings = $new_settings;

    if ($smart_date_enabled) {
      $smart_date_widget_defaults = [
        'default_duration' => $smart_date_duration,
        'default_duration_increments' => $smart_date_duration_increments,
      ];
      // Forcefully apply defaults if they are missing or null. This is more
      // robust than the array union operator, which doesn't handle nulls.
      foreach ($smart_date_widget_defaults as $key => $value) {
        if (!isset($new_settings[$key])) {
          $new_settings[$key] = $value;
        }
      }
    }

    // Check if the component needs to be updated due to changed settings.
    if ($new_settings !== $original_settings) {
      $needs_save = TRUE;
    }

    if ($needs_save) {
      $new_component = [
        'type' => $target_widget,
        'weight' => $component['weight'] ?? -10,
        'region' => $component['region'] ?? 'content',
        'settings' => $new_settings,
      ];
      $fd->setComponent($field_storage_name, $new_component)->save();
    }
  }

  // === 4. View Display ===
  if ($vd = $em->getStorage('entity_view_display')->load('node.appointment.default')) {
    $target_formatter = $smart_date_enabled ? 'smartdate_default' : 'daterange_default';
    $component = $vd->getComponent($field_storage_name);
    $needs_save = FALSE;
    // Only update if component is missing or has the wrong type.
    if (!$component || $component['type'] !== $target_formatter) {
      $new_component = [
        'type' => $target_formatter,
        'label' => $component['label'] ?? 'above',
        'weight' => $component['weight'] ?? -10,
        'settings' => $component['settings'] ?? [],
      ];
      $component = $new_component;
      $needs_save = TRUE;
    }

    if ($target_formatter === 'smartdate_default') {
      $smart_date_view_defaults = [
        'format' => 'default',
        'separator' => ' - ',
        'display_all_day' => FALSE,
        'parts' => ['start', 'end'],
      ];
      $component_settings = $component['settings'] ?? [];
      foreach ($smart_date_view_defaults as $key => $value) {
        $current = $component_settings[$key] ?? NULL;
        if ($key === 'parts') {
          $is_missing = !is_array($current) || !$current;
        }
        else {
          $is_missing = $current === NULL || $current === '';
        }
        if ($is_missing) {
          $component_settings[$key] = $value;
          $needs_save = TRUE;
        }
      }
      $component['settings'] = $component_settings;
    }

    if ($needs_save) {
      $vd->setComponent($field_storage_name, $component)->save();
    }
  }
}


/**
 * Create/attach capacity fields in a safe, idempotent way.
 */
function appointment_facilitator_ensure_fields(string $badges_vid, ?string $profile_bundle = NULL): void {
  // Appointment fields (content type: appointment).
  if (!FieldStorageConfig::loadByName('node', 'field_appointment_attendees')) {
    FieldStorageConfig::create([
      'field_name' => 'field_appointment_attendees',
      'entity_type' => 'node',
      'type' => 'entity_reference',
      'settings' => ['target_type' => 'user'],
      'cardinality' => -1,
    ])->save();
  }
  if (!FieldConfig::loadByName('node', 'appointment', 'field_appointment_attendees')) {
    FieldConfig::create([
      'field_name' => 'field_appointment_attendees',
      'entity_type' => 'node',
      'bundle' => 'appointment',
      'label' => 'Attendees',
      'settings' => ['handler' => 'default'],
    ])->save();
  }

  if (!FieldStorageConfig::loadByName('node', 'field_facilitator_arrival_status')) {
    FieldStorageConfig::create([
      'field_name' => 'field_facilitator_arrival_status',
      'entity_type' => 'node',
      'type' => 'list_string',
      'settings' => [
        'allowed_values' => [
          'on_time' => 'On time',
          'late_grace' => 'Late (grace)',
          'late' => 'Late',
          'missed' => 'Missed',
        ],
      ],
      'cardinality' => 1,
    ])->save();
  }
  if (!FieldConfig::loadByName('node', 'appointment', 'field_facilitator_arrival_status')) {
    FieldConfig::create([
      'field_name' => 'field_facilitator_arrival_status',
      'entity_type' => 'node',
      'bundle' => 'appointment',
      'label' => 'Facilitator arrival status',
    ])->save();
  }

  if (!FieldStorageConfig::loadByName('node', 'field_facilitator_arrival_time')) {
    FieldStorageConfig::create([
      'field_name' => 'field_facilitator_arrival_time',
      'entity_type' => 'node',
      'type' => 'datetime',
      'settings' => [
        'datetime_type' => 'datetime',
      ],
      'cardinality' => 1,
    ])->save();
  }
  if (!FieldConfig::loadByName('node', 'appointment', 'field_facilitator_arrival_time')) {
    FieldConfig::create([
      'field_name' => 'field_facilitator_arrival_time',
      'entity_type' => 'node',
      'bundle' => 'appointment',
      'label' => 'Facilitator first scan time',
    ])->save();
  }

  // Badge capacity on taxonomy terms (Badges vocabulary).
  if ($badges_vid && \Drupal::entityTypeManager()->getStorage('taxonomy_vocabulary')->load($badges_vid)) {
    if (!FieldStorageConfig::loadByName('taxonomy_term', 'field_badge_capacity')) {
      FieldStorageConfig::create([
        'field_name' => 'field_badge_capacity',
        'entity_type' => 'taxonomy_term',
        'type' => 'integer',
        'settings' => ['min' => 1],
        'cardinality' => 1,
      ])->save();
    }
    if (!FieldConfig::loadByName('taxonomy_term', $badges_vid, 'field_badge_capacity')) {
      FieldConfig::create([
        'field_name' => 'field_badge_capacity',
        'entity_type' => 'taxonomy_term',
        'bundle' => $badges_vid,
        'label' => 'Badge Max Attendees',
      ])->save();
    }
  }

  // Facilitator capacity on Profile (bundle configurable).
  if ($profile_bundle && \Drupal::moduleHandler()->moduleExists('profile')) {
    $ptype = \Drupal::entityTypeManager()->getStorage('profile_type')->load($profile_bundle);
    if ($ptype) {
      if (!FieldStorageConfig::loadByName('profile', 'field_coordinator_capacity')) {
        FieldStorageConfig::create([
          'field_name' => 'field_coordinator_capacity',
          'entity_type' => 'profile',
          'type' => 'integer',
          'settings' => ['min' => 1],
          'cardinality' => 1,
        ])->save();
      }
      if (!FieldConfig::loadByName('profile', $profile_bundle, 'field_coordinator_capacity')) {
        FieldConfig::create([
          'field_name' => 'field_coordinator_capacity',
          'entity_type' => 'profile',
          'bundle' => $profile_bundle,
          'label' => 'Max Attendees Per Appointment',
        ])->save();
      }
    }
  }
}

/**
 * Ensure form & view displays surface our fields (idempotent).
 */
function appointment_facilitator_ensure_displays(?string $badges_vid = 'badges', ?string $profile_bundle = 'coordinator'): void {
  $em = \Drupal::entityTypeManager();

  // Form display for node.appointment.
  if ($fd = $em->getStorage('entity_form_display')->load('node.appointment.default')) {
    if ($fd->getComponent('field_appointment_attendees') === NULL) {
      $fd->setComponent('field_appointment_attendees', ['type' => 'entity_reference_autocomplete', 'weight' => -8, 'region' => 'content']);
    }
    if ($fd->getComponent('field_facilitator_arrival_status') === NULL) {
      $fd->setComponent('field_facilitator_arrival_status', ['type' => 'options_select', 'weight' => 98, 'region' => 'content']);
    }
    if ($fd->getComponent('field_facilitator_arrival_time') === NULL) {
      $fd->setComponent('field_facilitator_arrival_time', ['type' => 'datetime_default', 'weight' => 99, 'region' => 'content']);
    }
    // Remove the old capacity field if it exists on the display.
    if ($fd->getComponent('field_appointment_capacity') !== NULL) {
      $fd->removeComponent('field_appointment_capacity');
    }
    $fd->save();
  }

  // View display for node.appointment.
  if ($vd = $em->getStorage('entity_view_display')->load('node.appointment.default')) {
    if ($vd->getComponent('field_appointment_attendees') === NULL) {
      $vd->setComponent('field_appointment_attendees', ['type' => 'entity_reference_label', 'label' => 'above', 'weight' => -8, 'settings' => ['link' => TRUE]]);
    }
    if ($vd->getComponent('field_facilitator_arrival_status') === NULL) {
      $vd->setComponent('field_facilitator_arrival_status', ['type' => 'list_default', 'label' => 'above', 'weight' => 98, 'region' => 'content']);
    }
    if ($vd->getComponent('field_facilitator_arrival_time') === NULL) {
      $vd->setComponent('field_facilitator_arrival_time', ['type' => 'datetime_default', 'label' => 'above', 'weight' => 99, 'region' => 'content']);
    }
    // Remove the old capacity field if it exists on the display.
    if ($vd->getComponent('field_appointment_capacity') !== NULL) {
      $vd->removeComponent('field_appointment_capacity');
    }
    $vd->save();
  }

  // Form display for badge capacity.
  if ($badges_vid && $em->getStorage('entity_form_display')->load('taxonomy_term.' . $badges_vid . '.default')) {
    $fd_badge = $em->getStorage('entity_form_display')->load('taxonomy_term.' . $badges_vid . '.default');
    if ($fd_badge->getComponent('field_badge_capacity') === NULL) {
      $fd_badge->setComponent('field_badge_capacity', ['type' => 'number', 'weight' => 10, 'region' => 'content']);
      $fd_badge->save();
    }
  }

  // Form display for profile capacity.
  if ($profile_bundle && \Drupal::moduleHandler()->moduleExists('profile') && $em->getStorage('entity_form_display')->load('profile.' . $profile_bundle . '.default')) {
    $fd_profile = $em->getStorage('entity_form_display')->load('profile.' . $profile_bundle . '.default');
    if ($fd_profile->getComponent('field_coordinator_capacity') === NULL) {
      $fd_profile->setComponent('field_coordinator_capacity', ['type' => 'number', 'weight' => 10, 'region' => 'content']);
      $fd_profile->save();
    }
  }
}

/**
 * Implements hook_install().
 */
function appointment_facilitator_install() {
  $conf = \Drupal::configFactory()->getEditable('appointment_facilitator.settings');
  $badges = $conf->get('badges_vocab_machine_name') ?: 'badges';
  $bundle = $conf->get('facilitator_profile_bundle') ?: 'coordinator';

  _appointment_facilitator_ensure_timerange_and_displays();
  appointment_facilitator_ensure_fields($badges, $bundle);
  appointment_facilitator_ensure_displays($badges, $bundle);
}

/**
 * Update: ensure fields & displays even on existing sites.
 */
function appointment_facilitator_update_9007() {
  $conf = \Drupal::config('appointment_facilitator.settings');
  $badges = $conf->get('badges_vocab_machine_name') ?: 'badges';
  $bundle = $conf->get('facilitator_profile_bundle') ?: 'coordinator';

  appointment_facilitator_ensure_fields($badges, $bundle);
  appointment_facilitator_ensure_displays($badges, $bundle);
}

/**
 * Update: Remove the per-appointment capacity field.
 */
function appointment_facilitator_update_9008() {
  $field_storage = FieldStorageConfig::loadByName('node', 'field_appointment_capacity');
  if ($field_storage) {
    $field_storage->delete();
  }

  $field = FieldConfig::loadByName('node', 'appointment', 'field_appointment_capacity');
  if ($field) {
    $field->delete();
  }
}

/**
 * Implements hook_requirements().
 */
function appointment_facilitator_requirements($phase) {
  $requirements = [];
  if ($phase !== 'runtime') {
    return $requirements;
  }

  $conf = \Drupal::config('appointment_facilitator.settings');
  $badges = $conf->get('badges_vocab_machine_name') ?: 'badges';
  $bundle = $conf->get('facilitator_profile_bundle') ?: 'coordinator';

  // Check appointment fields.
  $need = [];
  foreach (['field_appointment_timerange', 'field_appointment_attendees', 'field_facilitator_arrival_status', 'field_facilitator_arrival_time'] as $fname) {
    if (!\Drupal\field\Entity\FieldConfig::loadByName('node', 'appointment', $fname)) {
      $need[] = $fname;
    }
  }
  if ($need) {
    $requirements['appointment_facilitator_appointment_fields'] = [
      'title' => t('Appointment Facilitator: Appointment fields'),
      'value' => t('Missing fields: @list', ['@list' => implode(', ', $need)]),
      'severity' => REQUIREMENT_WARNING,
    ];
  }

  // Check badges capacity field.
  $has_badges = (bool) \Drupal::entityTypeManager()->getStorage('taxonomy_vocabulary')->load($badges);
  if ($has_badges && !\Drupal\field\Entity\FieldConfig::loadByName('taxonomy_term', $badges, 'field_badge_capacity')) {
    $requirements['appointment_facilitator_badge_field'] = [
      'title' => t('Appointment Facilitator: Badge capacity'),
      'value' => t('The vocabulary "@vid" is missing field_badge_capacity.', ['@vid' => $badges]),
      'severity' => REQUIREMENT_WARNING,
    ];
  }

  // Check facilitator profile capacity field if profile module exists.
  if (\Drupal::moduleHandler()->moduleExists('profile')) {
    $ptype = \Drupal::entityTypeManager()->getStorage('profile_type')->load($bundle);
    if ($ptype && !\Drupal\field\Entity\FieldConfig::loadByName('profile', $bundle, 'field_coordinator_capacity')) {
      $requirements['appointment_facilitator_profile_field'] = [
        'title' => t('Appointment Facilitator: Facilitator capacity'),
        'value' => t('The profile bundle "@bundle" is missing field_coordinator_capacity.', ['@bundle' => $bundle]),
        'severity' => REQUIREMENT_WARNING,
    ];
    }
  }

  return $requirements;
}

/**
 * Update: Re-ensure fields & displays to fix any prior issues.
 */
function appointment_facilitator_update_9009() {
  $conf = \Drupal::config('appointment_facilitator.settings');
  $badges = $conf->get('badges_vocab_machine_name') ?: 'badges';
  $bundle = $conf->get('facilitator_profile_bundle') ?: 'coordinator';

  appointment_facilitator_ensure_fields($badges, $bundle);
  appointment_facilitator_ensure_displays($badges, $bundle);
}

/**
 * Update: Ensure timerange field and displays are correctly configured.
 */
function appointment_facilitator_update_9010() {
  _appointment_facilitator_ensure_timerange_and_displays();
}

/**
 * Update: Ensure Smart Date defaults exist on the timerange field.
 */
function appointment_facilitator_update_9011() {
  _appointment_facilitator_ensure_timerange_and_displays();
}

/**
 * Update: Remove Smart Date default values so the field stays empty by default.
 */
function appointment_facilitator_update_9012() {
  _appointment_facilitator_ensure_timerange_and_displays();
}

/**
 * Update: Ensure Smart Date formatter displays both start and end times.
 */
function appointment_facilitator_update_9013() {
  _appointment_facilitator_ensure_timerange_and_displays();
}

/**
 * Update: Ensure Smart Date defaults exist for appointment timerange.
 */
function appointment_facilitator_update_9014() {
  _appointment_facilitator_ensure_timerange_and_displays();
}

/**
 * Update: Fix corrupt menu link icons by converting strings to arrays.
 */
function appointment_facilitator_update_9015() {
  $uuids = [
    'eac63ca7-87ef-4012-925e-07783bd8732c',
    'e8595dd8-9dbd-4f60-a6cb-2d0cf2ac84a2',
    '67a3cd8a-5324-4658-b47d-555ee69ddddb',
    '38f19038-eb9d-416f-890c-42e777c591aa',
    '6fd08545-4cec-463f-a66f-14f0d41dc278',
    '795d8796-c397-496d-8550-cf646c6e3591',
    'b5f59fbb-73f4-4f35-a3ba-fa605c4231e5',
    '36e23dae-e454-42ce-b120-1458f53826bb',
    '458293fb-3304-4957-b8b1-156ee2e79b75',
  ];

  $storage = \Drupal::entityTypeManager()->getStorage('menu_link_content');
  $entities = $storage->loadByProperties(['uuid' => $uuids]);
  $count = 0;

  foreach ($entities as $entity) {
    $options = $entity->link->options;
    // Check if the 'icon' option is set and not an array.
    if (isset($options['icon']) && !is_array($options['icon'])) {
      $icon = $options['icon'];
      // Convert string icon to array format or empty array.
      if (is_string($icon) && $icon !== '') {
        $options['icon'] = ['icon_id' => $icon];
      }
      else {
        $options['icon'] = [];
      }
      $entity->link->options = $options;
      $entity->save();
      $count++;
    }
  }

  return t('Fixed @count menu link entities with invalid icon options.', ['@count' => $count]);
}

/**
 * Update: Fix ALL corrupt menu link icons by unsetting invalid string options.
 */
function appointment_facilitator_update_9016() {
  $storage = \Drupal::entityTypeManager()->getStorage('menu_link_content');
  $ids = $storage->getQuery()
    ->accessCheck(FALSE)
    ->execute();

  $entities = $storage->loadMultiple($ids);
  $count = 0;

  foreach ($entities as $entity) {
    $options = $entity->link->options;
    if (isset($options['icon']) && !is_array($options['icon'])) {
      unset($options['icon']);
      $entity->link->options = $options;
      $entity->save();
      $count++;
    }
  }

  return t('Fixed @count menu link entities with invalid icon options.', ['@count' => $count]);
}

/**
 * Update: Ensure facilitator arrival fields and displays exist.
 */
function appointment_facilitator_update_9017() {
  $conf = \Drupal::config('appointment_facilitator.settings');
  $badges = $conf->get('badges_vocab_machine_name') ?: 'badges';
  $bundle = $conf->get('facilitator_profile_bundle') ?: 'coordinator';

  appointment_facilitator_ensure_fields($badges, $bundle);
  appointment_facilitator_ensure_displays($badges, $bundle);
}
