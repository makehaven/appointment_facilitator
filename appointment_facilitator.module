<?php

use Drupal\appointment_facilitator\Form\JoinAppointmentForm;
use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Field\FieldItemListInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\node\NodeInterface;
use Drupal\Core\Session\AccountInterface;

/**
 * Compute effective capacity for an appointment node.
 *
 * Capacity is the minimum of the capacities defined on the appointment's
 * "badges" (taxonomy terms) and the facilitator's own capacity limit from
 * their profile.
 *
 * @param \Drupal\node\NodeInterface $node
 *   The appointment node.
 *
 * @return int
 *   The effective capacity, defaulting to 1.
 */
function appointment_facilitator_effective_capacity(NodeInterface $node): int {
  $caps = [];

  // Badge capacities.
  if ($node->hasField('field_appointment_badges') && !$node->get('field_appointment_badges')->isEmpty()) {
    foreach ($node->get('field_appointment_badges')->referencedEntities() as $term) {
      if (is_object($term) && $term->hasField('field_badge_capacity') && !$term->get('field_badge_capacity')->isEmpty()) {
        $caps[] = (int) $term->get('field_badge_capacity')->value;
      }
    }
  }

  // Facilitator capacity from Profile (configurable bundle).
  if ($node->hasField('field_appointment_host') && !$node->get('field_appointment_host')->isEmpty()) {
    $user = $node->get('field_appointment_host')->entity;
    $bundle = \Drupal::config('appointment_facilitator.settings')->get('facilitator_profile_bundle') ?: 'coordinator';
    if ($user && \Drupal::moduleHandler()->moduleExists('profile') && $bundle) {
      $profiles = \Drupal::entityTypeManager()->getStorage('profile')->loadByUser($user, $bundle);
      if ($profiles) {
        $profile = NULL;
        foreach ($profiles as $p) {
          $profile = $p;
          break;
        }
        if (is_object($profile) && $profile->hasField('field_coordinator_capacity') && !$profile->get('field_coordinator_capacity')->isEmpty()) {
          $caps[] = (int) $profile->get('field_coordinator_capacity')->value;
        }
      }
    }
  }

  $caps = array_filter(array_map('intval', $caps), fn($v) => $v > 0);
  return $caps ? min($caps) : 1;
}

/**
 * Implements hook_entity_view().
 *
 * Adds the capacity information and a "Join" CTA to appointment nodes.
 */
function appointment_facilitator_entity_view(array &$build, EntityInterface $entity, $view_mode, $langcode) {
  if ($entity->getEntityTypeId() !== 'node' || $entity->bundle() !== 'appointment' || $view_mode !== 'full') {
    return;
  }

  $account = \Drupal::currentUser();
  $effective_capacity = appointment_facilitator_effective_capacity($entity);

  // Add a capacity summary.
  $build['appointment_capacity_summary'] = [
    '#type' => 'container',
    '#attributes' => ['class' => ['appointment-capacity-summary']],
    'summary' => ['#markup' => '<div><strong>' . t('Capacity') . ':</strong> ' . $effective_capacity . '</div>'],
    '#weight' => -60,
  ];

  // Gate the Join CTA.
  if ($account->isAnonymous() || !$entity->hasField('field_appointment_attendees')) {
    return;
  }

  $form = \Drupal::formBuilder()->getForm(JoinAppointmentForm::class, $entity);
  if ($form) {
    $build['appointment_join'] = [
      '#type' => 'container',
      '#attributes' => ['class' => ['appointment-join-cta']],
      'form' => $form,
      '#weight' => -50,
    ];
  }
}

/**
 * Implements hook_entity_form_display_alter().
 *
 * Provides default settings for Smart Date widgets to prevent fatal errors
 * when the field is not configured as expected.
 *
 * @see https://www.drupal.org/project/smart_date/issues/3422612
 */
function appointment_facilitator_entity_form_display_alter(&$form_display, $context) {
  if ($context['entity_type'] !== 'node' || $context['bundle'] !== 'appointment') {
    return;
  }

  $smart_date_widgets = [
    'smartdate_inline',
    'smartdate_default',
    'smartdate_timestamp',
  ];
  $fields = [
    'field_appointment_timerange',
    'field_appointment_date',
  ];

  foreach ($fields as $field_name) {
    if (!$component = $form_display->getComponent($field_name)) {
      continue;
    }
    if (!in_array($component['type'], $smart_date_widgets, TRUE)) {
      continue;
    }
    $updated = FALSE;
    if (empty($component['settings']['default_duration_increments'])) {
      $component['settings']['default_duration_increments'] = "1\n5\n10\n15\n30\n45\n60";
      $updated = TRUE;
    }
    if (empty($component['settings']['default_duration'])) {
      $component['settings']['default_duration'] = 60;
      $updated = TRUE;
    }
    if ($updated) {
      $form_display->setComponent($field_name, $component);
    }
  }
}

/**
 * Implements hook_navigation_menu_link_tree_alter().
 *
 * Normalizes icon options to arrays to avoid merge errors in the navigation
 * menu builder.
 */
function appointment_facilitator_navigation_menu_link_tree_alter(array &$tree): void {
  _appointment_facilitator_normalize_navigation_menu_icons($tree);
}

/**
 * Recursively normalize navigation menu link icon options.
 */
function _appointment_facilitator_normalize_navigation_menu_icons(array &$tree): void {
  foreach ($tree as $item) {
    if (!isset($item->link)) {
      continue;
    }
    $url = $item->link->getUrlObject();
    $icon = $url->getOption('icon');
    if ($icon !== NULL && !is_array($icon)) {
      if (is_string($icon) && $icon !== '') {
        $url->setOption('icon', ['icon_id' => $icon]);
      }
      else {
        $url->setOption('icon', []);
      }
    }
    if (!empty($item->subtree)) {
      _appointment_facilitator_normalize_navigation_menu_icons($item->subtree);
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function appointment_facilitator_node_presave(NodeInterface $node) {
  if ($node->bundle() !== 'appointment') {
    return;
  }
  _appointment_facilitator_populate_timerange_from_slots($node);
  _appointment_facilitator_sync_date_from_timerange($node);
}

/**
 * Implements hook_cron().
 */
function appointment_facilitator_cron(): void {
  if (!\Drupal::entityTypeManager()->hasDefinition('access_control_log')) {
    return;
  }

  $entity_field_manager = \Drupal::service('entity_field.manager');
  $access_fields = $entity_field_manager->getFieldDefinitions('access_control_log', 'access_control_request');
  if (!isset($access_fields['field_access_request_user'])) {
    return;
  }
  $node_fields = $entity_field_manager->getFieldDefinitions('node', 'appointment');
  if (!isset($node_fields['field_facilitator_arrival_status'])) {
    return;
  }

  $config = \Drupal::config('appointment_facilitator.settings');
  $backfill_days = max(1, (int) ($config->get('arrival_backfill_days') ?? 7));
  $site_timezone = \Drupal::config('system.date')->get('timezone.default') ?: date_default_timezone_get();
  $now = new \DateTimeImmutable('now', new \DateTimeZone($site_timezone));
  $start_date = $now->modify('-' . $backfill_days . ' days')->format('Y-m-d');

  $storage = \Drupal::entityTypeManager()->getStorage('node');
  $query = $storage->getQuery()
    ->accessCheck(FALSE)
    ->condition('type', 'appointment')
    ->condition('status', 1);

  if (isset($node_fields['field_appointment_status'])) {
    $query->condition('field_appointment_status.value', 'canceled', '<>');
  }
  if (isset($node_fields['field_appointment_date'])) {
    $query->condition('field_appointment_date.value', $start_date, '>=');
  }

  $nids = $query->execute();
  if (!$nids) {
    return;
  }

  $nodes = $storage->loadMultiple($nids);
  foreach ($nodes as $node) {
    if (!$node instanceof NodeInterface || $node->bundle() !== 'appointment') {
      continue;
    }

    if ($node->hasField('field_facilitator_arrival_status') && !$node->get('field_facilitator_arrival_status')->isEmpty()) {
      continue;
    }

    $window = _appointment_facilitator_get_arrival_window($node, $site_timezone);
    if (!$window) {
      continue;
    }

    if ($window['end_ts'] > $now->getTimestamp()) {
      continue;
    }

    $scan = _appointment_facilitator_find_arrival_scan($node, $window, $site_timezone);
    $status = _appointment_facilitator_classify_arrival($window['start'], $window['end'], $scan, (int) ($config->get('arrival_grace_minutes') ?? 5));

    $node->set('field_facilitator_arrival_status', $status);
    if ($scan && $node->hasField('field_facilitator_arrival_time')) {
      $node->set('field_facilitator_arrival_time', $scan->format('Y-m-d\TH:i:s'));
    }
    $node->save();
  }
}

/**
 * Implements hook_page_attachments().
 *
 * Exposes the configured site timezone so inline appointment display scripts
 * can format times consistently across client browsers.
 */
function appointment_facilitator_page_attachments(array &$attachments): void {
  $site_timezone = \Drupal::config('system.date')->get('timezone.default') ?: date_default_timezone_get();
  $attachments['#attached']['drupalSettings']['appointment_facilitator']['siteTimezone'] = $site_timezone;
}

/**
 * Implements hook_entity_field_access().
 */
function appointment_facilitator_entity_field_access(string $operation, FieldDefinitionInterface $field_definition, AccountInterface $account, ?FieldItemListInterface $items = NULL): AccessResult {
  if ($operation !== 'edit') {
    return AccessResult::neutral();
  }

  if ($field_definition->getTargetEntityTypeId() !== 'node' || $field_definition->getTargetBundle() !== 'appointment') {
    return AccessResult::neutral();
  }

  $field_name = $field_definition->getName();
  if (!in_array($field_name, ['field_facilitator_arrival_status', 'field_facilitator_arrival_time'], TRUE)) {
    return AccessResult::neutral();
  }

  if ($account->hasPermission('administer nodes') || $account->hasPermission('manage facilitator arrival fields')) {
    return AccessResult::allowed()->cachePerPermissions();
  }

  return AccessResult::forbidden()->cachePerPermissions();
}

/**
 * Implements hook_form_node_form_alter().
 */
function appointment_facilitator_form_node_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  $entity = $form_state->getFormObject()?->getEntity();
  if (!$entity instanceof NodeInterface || $entity->bundle() !== 'appointment') {
    return;
  }

  $account = \Drupal::currentUser();
  if ($account->hasPermission('administer nodes') || $account->hasPermission('manage facilitator arrival fields')) {
    return;
  }

  unset($form['field_facilitator_arrival_status'], $form['field_facilitator_arrival_time']);
}

/**
 * Populates the Smart Date timerange from legacy slot selections.
 */
function _appointment_facilitator_populate_timerange_from_slots(NodeInterface $node): void {
  if (!$node->hasField('field_appointment_timerange') || !$node->hasField('field_appointment_slot')) {
    return;
  }
  if (!$node->get('field_appointment_timerange')->isEmpty()) {
    // Do not overwrite existing data unless the field is empty.
    return;
  }
  if ($node->get('field_appointment_slot')->isEmpty()) {
    return;
  }

  $base_date = _appointment_facilitator_resolve_base_date($node);
  if (!$base_date) {
    return;
  }

  $slot_offsets = _appointment_facilitator_extract_slot_offsets($node);
  if (!$slot_offsets) {
    return;
  }

  $base_start = _appointment_facilitator_resolve_slot_base_time($node, $base_date);
  if (!$base_start instanceof \DateTimeImmutable) {
    return;
  }

  sort($slot_offsets);
  $min_offset = min($slot_offsets);
  $max_offset = max($slot_offsets);
  $duration_minutes = ($max_offset - $min_offset) + 30;

  $appointment_start = $base_start->modify('+' . $min_offset . ' minutes');
  $appointment_end = $appointment_start->modify('+' . $duration_minutes . ' minutes');
  $timezone = $appointment_start->getTimezone()->getName();

  $field = $node->get('field_appointment_timerange');
  $field_type = $field->getFieldDefinition()->getType();
  $start_timestamp = $appointment_start->getTimestamp();
  $end_timestamp = $appointment_end->getTimestamp();

  if ($field_type === 'smartdate') {
    $field->setValue([[
      'value' => $start_timestamp,
      'end_value' => $end_timestamp,
      'duration' => $duration_minutes,
      'timezone' => $timezone,
    ]]);
  }
  else {
    $start_string = $appointment_start->format('Y-m-d\TH:i:s');
    $end_string = $appointment_end->format('Y-m-d\TH:i:s');
    $field->setValue([[
      'value' => $start_string,
      'end_value' => $end_string,
    ]]);
  }

  if ($node->hasField('field_host_start_time') && $node->get('field_host_start_time')->isEmpty()) {
    $node->set('field_host_start_time', $base_start->format('Y-m-d\TH:i:s'));
  }
}

/**
 * Builds the arrival evaluation window for an appointment.
 */
function _appointment_facilitator_get_arrival_window(NodeInterface $node, string $site_timezone): ?array {
  $config = \Drupal::config('appointment_facilitator.settings');
  $pre_window_minutes = max(0, (int) ($config->get('arrival_pre_window_minutes') ?? 30));
  $timezone = new \DateTimeZone($site_timezone ?: date_default_timezone_get());

  if ($node->hasField('field_appointment_timerange') && !$node->get('field_appointment_timerange')->isEmpty()) {
    $item = $node->get('field_appointment_timerange')->first();
    $range_timezone = $item->timezone ?: $timezone->getName();
    $range_tz = new \DateTimeZone($range_timezone);

    try {
      if (is_numeric($item->value)) {
        $start = (new \DateTimeImmutable('@' . (int) $item->value))->setTimezone($range_tz);
      }
      else {
        $start = new \DateTimeImmutable($item->value, $range_tz);
      }
      if (!empty($item->end_value)) {
        if (is_numeric($item->end_value)) {
          $end = (new \DateTimeImmutable('@' . (int) $item->end_value))->setTimezone($range_tz);
        }
        else {
          $end = new \DateTimeImmutable($item->end_value, $range_tz);
        }
      }
      else {
        $end = $start->modify('+60 minutes');
      }
    }
    catch (\Exception $e) {
      return NULL;
    }

    $start_ts = $start->getTimestamp() - ($pre_window_minutes * 60);
    return [
      'start' => $start,
      'end' => $end,
      'start_ts' => $start_ts,
      'end_ts' => $end->getTimestamp(),
    ];
  }

  if ($node->hasField('field_appointment_date') && !$node->get('field_appointment_date')->isEmpty()) {
    $base_date = _appointment_facilitator_normalize_date($node->get('field_appointment_date')->value);
    if ($base_date && $node->hasField('field_host_start_time') && !$node->get('field_host_start_time')->isEmpty()) {
      $start = _appointment_facilitator_parse_slot_time($base_date, (string) $node->get('field_host_start_time')->value, $timezone->getName());
      if ($start instanceof \DateTimeImmutable) {
        $end = $start->modify('+60 minutes');
        $start_ts = $start->getTimestamp() - ($pre_window_minutes * 60);
        return [
          'start' => $start,
          'end' => $end,
          'start_ts' => $start_ts,
          'end_ts' => $end->getTimestamp(),
        ];
      }
    }
  }

  return NULL;
}

/**
 * Finds the first access scan in the arrival window for the facilitator.
 */
function _appointment_facilitator_find_arrival_scan(NodeInterface $node, array $window, string $site_timezone): ?\DateTimeImmutable {
  if (!$node->hasField('field_appointment_host') || $node->get('field_appointment_host')->isEmpty()) {
    return NULL;
  }
  $uid = (int) $node->get('field_appointment_host')->target_id;
  if ($uid <= 0) {
    return NULL;
  }

  $storage = \Drupal::entityTypeManager()->getStorage('access_control_log');
  $query = $storage->getQuery()
    ->accessCheck(FALSE)
    ->condition('type', 'access_control_request')
    ->condition('field_access_request_user.target_id', $uid)
    ->condition('created', $window['start_ts'], '>=')
    ->condition('created', $window['end_ts'], '<=')
    ->sort('created', 'ASC')
    ->range(0, 1);

  $ids = $query->execute();
  if (!$ids) {
    return NULL;
  }
  $logs = $storage->loadMultiple($ids);
  $log = reset($logs);
  if (!$log) {
    return NULL;
  }

  $timestamp = NULL;
  if (method_exists($log, 'getCreatedTime')) {
    $timestamp = (int) $log->getCreatedTime();
  }
  elseif ($log->hasField('created') && !$log->get('created')->isEmpty()) {
    $timestamp = (int) $log->get('created')->value;
  }

  if (!$timestamp) {
    return NULL;
  }

  return (new \DateTimeImmutable('@' . $timestamp))
    ->setTimezone(new \DateTimeZone($site_timezone ?: date_default_timezone_get()));
}

/**
 * Classifies the arrival status using the scan time and grace window.
 */
function _appointment_facilitator_classify_arrival(
  \DateTimeImmutable $start,
  \DateTimeImmutable $end,
  ?\DateTimeImmutable $scan,
  int $grace_minutes
): string {
  if (!$scan) {
    return 'missed';
  }

  if ($scan <= $start) {
    return 'on_time';
  }

  $grace_cutoff = $start->modify('+' . max(0, $grace_minutes) . ' minutes');
  if ($scan <= $grace_cutoff) {
    return 'late_grace';
  }

  if ($scan <= $end) {
    return 'late';
  }

  return 'missed';
}

/**
 * Ensures the appointment date field mirrors the timerange start.
 */
function _appointment_facilitator_sync_date_from_timerange(NodeInterface $node): void {
  if (!$node->hasField('field_appointment_date') || !$node->get('field_appointment_date')->isEmpty()) {
    return;
  }
  if (!$node->hasField('field_appointment_timerange') || $node->get('field_appointment_timerange')->isEmpty()) {
    return;
  }

  $item = $node->get('field_appointment_timerange')->first();
  if (!$item || $item->value === NULL || $item->value === '') {
    return;
  }

  $timezone = $item->timezone ?: (\Drupal::config('system.date')->get('timezone.default') ?: date_default_timezone_get());

  try {
    if (is_numeric($item->value)) {
      $date = (new \DateTimeImmutable('@' . (int) $item->value))
        ->setTimezone(new \DateTimeZone($timezone));
    }
    else {
      $date = new \DateTimeImmutable($item->value, new \DateTimeZone($timezone));
    }
  }
  catch (\Exception $e) {
    return;
  }

  $node->set('field_appointment_date', $date->format('Y-m-d'));
}

/**
 * Returns the slot offset map used by legacy checkboxes.
 */
function _appointment_facilitator_slot_offset_map(): array {
  return [
    '1' => 0,
    '1-5' => 30,
    '2' => 60,
    '2-5' => 90,
    '3' => 120,
    '3-5' => 150,
  ];
}

/**
 * Converts selected slot values to minute offsets.
 */
function _appointment_facilitator_extract_slot_offsets(NodeInterface $node): array {
  $map = _appointment_facilitator_slot_offset_map();
  $offsets = [];
  foreach ($node->get('field_appointment_slot')->getValue() as $selection) {
    $value = $selection['value'] ?? NULL;
    if ($value !== NULL && isset($map[$value])) {
      $offsets[] = $map[$value];
    }
  }
  sort($offsets);
  return array_values(array_unique($offsets));
}

/**
 * Resolves the base start time for a facilitator shift.
 */
function _appointment_facilitator_resolve_slot_base_time(NodeInterface $node, string $base_date): ?\DateTimeImmutable {
  $timezone = \Drupal::config('system.date')->get('timezone.default') ?: date_default_timezone_get();
  $request = \Drupal::service('request_stack')->getCurrentRequest();
  $candidates = [];

  if ($request) {
    $param = $request->query->get('start_time');
    if (!$param) {
      $param = $request->request->get('start_time');
    }
    if (!empty($param)) {
      $candidates[] = $param;
    }
  }

  if ($node->hasField('field_host_start_time') && !$node->get('field_host_start_time')->isEmpty()) {
    $candidates[] = $node->get('field_host_start_time')->value;
  }

  foreach ($candidates as $raw_time) {
    $parsed = _appointment_facilitator_parse_slot_time($base_date, (string) $raw_time, $timezone);
    if ($parsed instanceof \DateTimeImmutable) {
      return $parsed;
    }
  }

  return NULL;
}

/**
 * Parses a time string into a DateTimeImmutable using the supplied date.
 */
function _appointment_facilitator_parse_slot_time(string $base_date, string $time_value, string $timezone): ?\DateTimeImmutable {
  $time_value = trim($time_value);
  if ($time_value === '') {
    return NULL;
  }

  try {
    $base_timezone = new \DateTimeZone($timezone);
    $base_day = new \DateTimeImmutable($base_date . ' 00:00:00', $base_timezone);
  }
  catch (\Exception $e) {
    return NULL;
  }

  if (is_numeric($time_value)) {
    try {
      return (new \DateTimeImmutable('@' . (int) $time_value))->setTimezone($base_timezone);
    }
    catch (\Exception $e) {
      return NULL;
    }
  }

  // Full ISO string with timezone.
  if (preg_match('/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}(:\d{2})?(Z|[+-]\d{2}:?\d{2})$/i', $time_value)) {
    try {
      return new \DateTimeImmutable($time_value);
    }
    catch (\Exception $e) {
      // Fall through.
    }
  }

  if (preg_match('/^\d{4}-\d{2}-\d{2}/', $time_value)) {
    try {
      return new \DateTimeImmutable($time_value, $base_timezone);
    }
    catch (\Exception $e) {
      return NULL;
    }
  }

  if (preg_match('/^(\d{1,2}):(\d{2})(am|pm)$/i', $time_value, $matches)) {
    $hours = (int) $matches[1];
    $minutes = (int) $matches[2];
    $ampm = strtolower($matches[3]);
    if ($ampm === 'pm' && $hours < 12) {
      $hours += 12;
    }
    elseif ($ampm === 'am' && $hours === 12) {
      $hours = 0;
    }
    return $base_day->setTime($hours, $minutes);
  }

  if (preg_match('/^(\d{1,2}):(\d{2})$/', $time_value, $matches)) {
    return $base_day->setTime((int) $matches[1], (int) $matches[2]);
  }

  try {
    return new \DateTimeImmutable($base_date . ' ' . $time_value, $base_timezone);
  }
  catch (\Exception $e) {
    try {
      $parsed = new \DateTimeImmutable($time_value, $base_timezone);
      return $base_day->setTime((int) $parsed->format('H'), (int) $parsed->format('i'), (int) $parsed->format('s'));
    }
    catch (\Exception $e2) {
      \Drupal::logger('appointment_facilitator')->warning('Unable to parse start_time "@time" for @date.', [
        '@time' => $time_value,
        '@date' => $base_date,
      ]);
      return NULL;
    }
  }
}

/**
 * Attempts to determine the appointment date for slot calculations.
 */
function _appointment_facilitator_resolve_base_date(NodeInterface $node): ?string {
  if ($node->hasField('field_appointment_date') && !$node->get('field_appointment_date')->isEmpty()) {
    $normalized = _appointment_facilitator_normalize_date($node->get('field_appointment_date')->value);
    if ($normalized) {
      return $normalized;
    }
  }

  $request = \Drupal::service('request_stack')->getCurrentRequest();
  if ($request) {
    $candidates = [];
    $structured_date = $request->request->get('field_appointment_date');
    if (is_array($structured_date)) {
      $candidates[] = $structured_date[0]['value'] ?? NULL;
    }
    $candidates[] = $request->query->get('date');
    $candidates[] = $request->request->get('date');
    foreach ($candidates as $candidate) {
      $normalized = _appointment_facilitator_normalize_date($candidate);
      if ($normalized) {
        return $normalized;
      }
    }
  }

  return NULL;
}

/**
 * Normalizes various date inputs to Y-m-d.
 */
function _appointment_facilitator_normalize_date(?string $value): ?string {
  if ($value === NULL) {
    return NULL;
  }
  $value = trim($value);
  if ($value === '') {
    return NULL;
  }

  $timezone_name = \Drupal::config('system.date')->get('timezone.default') ?: date_default_timezone_get();
  $timezone = new \DateTimeZone($timezone_name);

  try {
    if (preg_match('/^\d{4}-\d{2}-\d{2}$/', $value)) {
      $date = new \DateTimeImmutable($value . ' 00:00:00', $timezone);
    }
    else {
      $date = new \DateTimeImmutable($value);
      $date = $date->setTimezone($timezone);
    }
  }
  catch (\Exception $e) {
    return NULL;
  }

  return $date->format('Y-m-d');
}
